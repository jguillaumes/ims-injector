package main

import (
	"flag"
	"os"

	"github.com/jguillaumes/ims-injector/internal/irm"
	log "github.com/sirupsen/logrus"
)

/*
ims-injector is a tool to inject messages into IMS systems.
This tool allow to send transactions to an IMS system using the IMSConnect HWSSMPL0 exit.
The messages are read from a file, and the responses are saved in an output file.

Usage:

	ims-injector [options] <input file> <output file>

The options are:

	-h <host>	   The host name or IP address of the IMS system (No default, required)
	-p <port>	   The port number of the IMS system (Default: 4200)
	-d <datastore> The datastore name (No default, required)
	-t <timeout>   The timeout in seconds for the transaction (Default: 30)
	-u <user>	   The user name to connect to the IMS system (No default, required if OTMA security is enabled)
	-w <password>  The password to connect to the IMS system (No default, required if OTMA security is enabled)
	-c <clientid>  The client ID to use for the connection (Default: generated by the IMS system)
	-t <lterm>	   The logical terminal name to use for the connection (Default: "INJECTOR")
	-k <concurrent> The number of concurrent transactions to send (Default: 1)

The tool opens a persistent socket to the IMS systemn and sends the transactions read from the file in sequence.
It waits for the responses and saves them in the output file. If <concurrent> is greater than 1, it starts
goroutines to send the transactions concurrently. The transactions are picked from the input file using
a round-robin algorithm, and the responses are saved in the output file in the order the responses are received. Notice
the order could be different from the order of the input transactions if the transactions are sent concurrently.
*/
func main() {
	numtransactions := 0
	numOK := 0
	numKO := 0

	logf := log.TextFormatter{
		PadLevelText:           true,
		DisableLevelTruncation: true,
		FullTimestamp:          true,
		TimestampFormat:        "02-Jan-2006 03:04:05.000",
	}
	log.SetFormatter(&logf)
	log.Info("Welcome to the IMS Injector!")

	// Command line arguments parsing
	host := flag.String("h", "", "IMS system host name or IP address (required)")
	port := flag.Int("p", 4200, "IMS system port number (default: 4200)")
	datastore := flag.String("d", "", "IMS datastore name (required)")
	timeout := flag.Int("t", 30, "Transaction timeout in seconds (default: 30)")
	user := flag.String("u", "", "User name for IMS system (required if OTMA security is enabled)")
	password := flag.String("w", "", "Password for IMS system (required if OTMA security is enabled)")
	clientID := flag.String("c", "", "Client ID for the connection (default: generated by IMS system)")
	lterm := flag.String("l", "INJECTOR", "Logical terminal name for the connection (default: INJECTOR)")
	concurrent := flag.Int("k", 1, "Number of concurrent transactions to send (default: 1)")

	parseError := false

	err := flag.CommandLine.Parse(os.Args[1:])

	if err != nil {
		log.Fatalf("Error parsing command line arguments: %v", err)
		os.Exit(32)
	}

	if *host == "" {
		log.Fatal("Host name or IP address is required")
		parseError = true
	}

	if (*port < 1 || *port > 65535) && *port != 0 {
		log.Fatal("Port number must be between 1 and 65535")
		parseError = true
	}

	if datastore == nil || *datastore == "" {
		log.Fatal("Datastore name is required")
		parseError = true
	}

	if *timeout < 0 || *timeout > 255 {
		log.Fatal("Timeout must be between 0 and 255 seconds")
		parseError = true
	}

	if *concurrent < 0 {
		log.Fatal("Concurrent transactions must be greater than 0")
		parseError = true
	}

	if *concurrent > 1 {
		log.Warnf("Conncurrency is not yet supported. The %d valus is ignofred", *concurrent)
		_ = *concurrent
	}

	if parseError {
		flag.Usage()
		os.Exit(32)
	}

	irm := irm.NewIRM()
	irm.Irm_timer = uint8(*timeout)
	irm.Irm_clientid = *clientID
	irm.Irm_user.Irm_racf_userid = *user
	irm.Irm_user.Irm_racf_pw = *password
	irm.Irm_user.Irm_imsdestid = *datastore
	irm.Irm_user.Irm_lterm = *lterm

	log.Infof("Injector run finished. %d transactions processed, %d OK, %d KO", numtransactions, numOK, numKO)
	var returnCode int
	if numKO > 0 {
		returnCode = 1
	} else {
		returnCode = 0
	}
	os.Exit(returnCode)
}
