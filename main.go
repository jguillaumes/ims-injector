package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/jguillaumes/ims-injector/internal/irm"
	"github.com/jguillaumes/ims-injector/internal/irm_net"
	log "github.com/sirupsen/logrus"
)

/*
ims-injector is a tool to inject messages into IMS systems.
This tool allow to send transactions to an IMS system using the IMSConnect HWSSMPL0 exit.
The messages are read from a file, and the responses are saved in an output file.

Usage:

	ims-injector [options] <input file> <output file>

The options are:

	-i <host>	   The host name or IP address of the IMS system (No default, required)
	-p <port>	   The port number of the IMS system (Default: 4200)
	-d <datastore> The datastore name (No default, required)
	-t <timeout>   The timeout in seconds for the transaction (Default: 30)
	-u <user>	   The user name to connect to the IMS system (No default, required if OTMA security is enabled)
	-w <password>  The password to connect to the IMS system (No default, required if OTMA security is enabled)
	-c <clientid>  The client ID to use for the connection (Default: generated by the IMS system)
	-t <lterm>	   The logical terminal name to use for the connection (Default: "INJECTOR")
	-k <concurrent> The number of concurrent transactions to send (Default: 1)
	-v n           Enable verbose logging (1) or very verbose tracing(2)
	-h             Show usage help

The tool opens a persistent socket to the IMS systemn and sends the transactions read from the file in sequence.
It waits for the responses and saves them in the output file. If <concurrent> is greater than 1, it starts
goroutines to send the transactions concurrently. The transactions are picked from the input file using
a round-robin algorithm, and the responses are saved in the output file in the order the responses are received. Notice
the order could be different from the order of the input transactions if the transactions are sent concurrently.
*/
func main() {
	numtransactions := 0
	numOK := 0
	numKO := 0

	logf := log.TextFormatter{
		PadLevelText:           true,
		DisableLevelTruncation: true,
		FullTimestamp:          true,
		TimestampFormat:        "02-Jan-2006 03:04:05.000",
	}
	log.SetFormatter(&logf)
	log.Info("Welcome to the IMS Injector!")

	// Command line arguments parsing
	host := flag.String("i", "", "IMS system `hostname` or IP address (required)")
	port := flag.Int("p", 4200, "IMS system `port` number")
	datastore := flag.String("d", "        ", "IMS `datastore` name (required)")
	timeout := flag.Int("t", 30, "Transaction `timeout` in seconds")
	user := flag.String("u", "        ", "`User` name for IMS system (required if OTMA security is enabled)")
	password := flag.String("w", "        ", "`Password` for IMS system (required if OTMA security is enabled)")
	clientID := flag.String("c", "        ", "`ClientID` for the connection (default: generated by IMS system)")
	lterm := flag.String("l", "INJECTOR", "Logical terminal name (`lterm`) for the connection")
	concurrent := flag.Int("k", 1, "Number of concurrent transactions to send")
	verbose := flag.Int("v", 0, "Enable verbose logging")
	help := flag.Bool("h", false, "Show help text")

	flag.Usage = func() {
		w := flag.CommandLine.Output()
		fmt.Fprintf(w, "Usage of %s: {options} input_file output_file\n", os.Args[0])
		fmt.Fprintln(w, "The input file must contain an IMS transaction in each line. Blank lines and lines starting with an asterisk are ignored.")
		fmt.Fprintln(w, "The transaction output will be written into the output file, tagged with <resp>...</resp>")
		fmt.Fprintln(w, "The available options are:")
		flag.PrintDefaults()
	}

	parseError := false

	err := flag.CommandLine.Parse(os.Args[1:])

	if err != nil {
		log.Fatalf("Error parsing command line arguments: %v", err)
		os.Exit(32)
	}

	if *help {
		flag.Usage()
		os.Exit(1)
	}

	switch *verbose {
	case 0:
		break
	case 1:
		{
			log.SetLevel(log.DebugLevel)
			log.Info("Verbose logging enabled")
		}
	case 2:
		{
			log.SetLevel(log.TraceLevel)
			log.Info("Trace logging enabled")

		}
	}

	if *host == "" {
		log.Fatal("Host name or IP address is required")
		parseError = true
	}

	if (*port < 1 || *port > 65535) && *port != 0 {
		log.Fatal("Port number must be between 1 and 65535")
		parseError = true
	}

	if datastore == nil || *datastore == "" {
		log.Fatal("Datastore name is required")
		parseError = true
	}

	if *timeout < 0 || *timeout > 60 {
		log.Fatal("Timeout must be between 0 and 60 seconds")
		parseError = true
	}

	if *concurrent < 0 {
		log.Fatal("Concurrent transactions must be greater than 0")
		parseError = true
	}

	if *concurrent > 99 {
		log.Fatal("Concurrent transactions must be less or equal to 99")
		parseError = true
	}

	if strings.TrimSpace(*clientID) != "" && *concurrent > 1 {
		trClientId := strings.TrimSpace(*clientID)
		var maxlen int
		if *concurrent <= 10 {
			maxlen = 7
		} else {
			maxlen = 6
		}
		if len(trClientId) > maxlen {
			log.Fatalf("The client id length must not exceed %d due to concurrency of %d", maxlen, *concurrent)
		}
	}

	if parseError {
		flag.Usage()
		os.Exit(32)
	}

	log.Debugf("Host      : %s\n", *host)
	log.Debugf("Port      : %d\n", *port)
	log.Debugf("Datastore : %s\n", *datastore)
	log.Debugf("LTERM     : %s\n", *lterm)
	log.Debugf("ClientId  : %s\n", *clientID)
	log.Debugf("Username  : %s\n", *user)
	log.Debugf("Timeout   : %d\n", *timeout)
	log.Debugf("Concurrent: %d\n", *concurrent)

	irm_template := irm.NewIRM()
	irm_template.Irm_timer = convert_timeout(*timeout)
	irm_template.Irm_clientid = fmt.Sprintf("%-8s", *clientID)
	irm_template.Irm_user.Irm_racf_userid = fmt.Sprintf("%-8s", *user)
	irm_template.Irm_user.Irm_racf_pw = fmt.Sprintf("%-8s", *password)
	irm_template.Irm_user.Irm_imsdestid = fmt.Sprintf("%-8s", *datastore)
	irm_template.Irm_user.Irm_lterm = fmt.Sprintf("%-8s", *lterm)

	// Open the input file
	inputFile, err := os.Open(flag.Arg(0))
	if err != nil {
		log.Fatalf("Error opening input file: %v", err)
		os.Exit(32)
	}
	defer inputFile.Close()

	// Open the output file
	outputFile, err := os.Create(flag.Arg(1))
	if err != nil {
		log.Fatalf("Error creating output file: %v", err)
		os.Exit(32)
	}
	defer outputFile.Close()

	// Create channels for communication
	inc := make(chan string)      // Channel for incoming messages
	outc := make(chan string, 10) // Channel for outgoing messages
	errc := make(chan error)      // Channel for errors & control

	// Start the interaction goroutines
	for n := range *concurrent {
		go irm_net.Do_interaction(n, *host, uint16(*port), *irm_template, inc, outc, errc)
	}

	// Read messages from the input file and send them to the interaction goroutine
	scanner := bufio.NewScanner(inputFile)

	go func() {
		for scanner.Scan() {
			msg := scanner.Text()
			if msg == "" || msg[0:1] == "*" {
				continue // Skip empty lines and comments
			}
			numtransactions++
			inc <- msg // Send the message to the interaction goroutine
		}
		if err := scanner.Err(); err != nil {
			log.Fatalf("Error reading input file: %v", err)
			os.Exit(32)
		}
		// Close the input channel to signal the end of messages
		close(inc)
	}()

	ctrl := make(chan struct{})

	go func() {
		// Process the responses from the interaction goroutine
		for {
			select {
			case resp := <-outc:
				if resp != "" {
					numOK++
					// Write the response to the output file
					_, err := outputFile.WriteString(fmt.Sprintf("<resp>\n%s\n</resp>\n", resp))
					if err != nil {
						log.Errorf("Error writing response to output file: %v", err)
						numKO++
					}
				} else {
					numKO++
				}

			case err := <-errc:
				if err != nil && err != io.EOF {
					log.Errorf("Error during interaction: %v", err)
					numKO++
				} else {
					// A goroutine ended, subtract from concurrent number
					*concurrent--
				}
				// Exit the loop if there are no more active goroutines
				if *concurrent == 0 {
					ctrl <- struct{}{}
					return
				}
			}
		}
	}()

	// Wait for the interaction goroutine to finish
	<-ctrl
	// Close the output channel to signal the end of responses
	close(outc)

	log.Infof("Injector run finished. %d transactions processed, %d OK, %d KO", numtransactions, numOK, numKO)
	var returnCode int
	if numKO > 0 {
		returnCode = 1
	} else {
		returnCode = 0
	}
	os.Exit(returnCode)
}

/*
convert_timeout: Convert a timeout value in seconds to the corresponding OTMA value

See table 58 in the IMS Communications and Connections
(The table 58 is for the IMS14 version)

The default value for 0 is 0.5 seconds
*/
func convert_timeout(timeout int) byte {
	if timeout == 0 {
		return 0x1E // Default  = 0.5 seconds
	}
	base_time := byte(0x27)
	real_time := base_time + byte(timeout)
	return real_time
}
